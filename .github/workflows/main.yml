name: DevSecOps Build, Test & Deploy to ECS Pipeline

on:
  push:
    branches:
      - DevSecOps
  pull_request:
    branches:
      - DevSecOps

jobs:
  docker-build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Docker
        run: |
          sudo apt-get remove containerd.io
          sudo apt install docker.io docker-compose -y
          sudo apt-get install -y docker.io
          sudo systemctl start docker
          sudo systemctl enable docker

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose

      - name: Verify Docker installation
        run: |
          docker --version
          docker-compose --version

      - name: Install AWS Elastic Beanstalk CLI
        run: |
          pip install --upgrade --user awsebcli
          export PATH=$PATH:$HOME/.local/bin

      - name: Build Backend Image
        run: |
          docker build ./backend --file ./backend/Dockerfile --tag backend-image:$(date +%s)

      - name: Build Frontend Image
        run: |
          docker build ./frontend --file ./frontend/Dockerfile --tag frontend-image:$(date +%s)

      - name: Verify current directory
        run: |
          pwd
          ls -la

      - name: Run Docker Compose
        run: |
          docker-compose -f docker-compose.yml up -d

      - name: Check if Backend Container is Running
        run: |
          docker ps -a

      - name: Check docker logs
        run: |
          docker-compose logs backend

      - name: Check Backend Logs
        run: docker logs my-backend-container

      - name: Install curl in Backend Container
        run: |
          docker exec my-backend-container apt-get update
          docker exec my-backend-container apt-get install -y

      - name: Wait for MongoDB to Start
        run: sleep 10

      - name: Run Backend Unit Tests
        run: |
          docker exec my-backend-container mvn test

      - name: Shut Down Docker Compose
        run: |
          docker-compose -f docker-compose.yml down

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Perform ShiftLeft Scan
        uses: ShiftLeftSecurity/scan-action@master
        with:
          type: "credscan,java,depscan"
        env:
          SCAN_OUTPUT: reports
          SCAN_CREATE_BASELINE: true

      - name: View Dependency Scan Report (JSON)
        run: |
          echo "Dependency Scan Findings:"
          cat reports/depscan-report-universal.json

      - name: Print baseline scan report
        run: cat reports/.sastscan.baseline

  push-to-ecr:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }} # Still using the Region
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} #Still using Account ID
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY}}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION \
            | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

      - name: Build and tag backend image
        run: |
          docker build ./backend -t $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/${{ secrets.BACKEND_REPO }}:latest

      - name: Build and tag frontend image
        run: |
          docker build ./frontend -t $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/${{ secrets.FRONTEND_REPO }}:latest

      - name: Push backend image
        run: |
          docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/${{ secrets.BACKEND_REPO }}:latest

      - name: Push frontend image
        run: |
          docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/${{ secrets.FRONTEND_REPO }}:latest
  deploy-to-ecs:
    runs-on: ubuntu-latest
    needs: [push-to-ecr]
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      BACKEND_REPO_NAME: ${{ secrets.BACKEND_REPO }}
      FRONTEND_REPO_NAME: ${{ secrets.FRONTEND_REPO }}
      ECS_CLUSTER_NAME: my-ecs-cluster # Replace with your desired cluster name
      ECS_SERVICE_NAME_BACKEND: my-backend-service # Replace with your desired backend service name
      ECS_SERVICE_NAME_FRONTEND: my-frontend-service # Replace with your desired frontend service name
      TASK_DEFINITION_FAMILY_BACKEND: backend-task # Replace with your desired backend task definition family
      TASK_DEFINITION_FAMILY_FRONTEND: frontend-task # Replace with your desired frontend task definition family
      CONTAINER_NAME_BACKEND: backend # Should match the name in your task definition
      CONTAINER_NAME_FRONTEND: frontend # Should match the name in your task definition
      BACKEND_PORT: 8080 # Replace with your backend application port
      FRONTEND_PORT: 3000 # Replace with your frontend application port
      LOAD_BALANCER_NAME: my-load-balancer # Replace with your desired load balancer name (if using)
      LISTENER_ARN: ${{ secrets.LISTENER_ARN }} # ARN of your Application Load Balancer listener (if using)
      VPC_ID: ${{ secrets.VPC_ID }} # Your VPC ID
      SUBNET_IDS: ${{ secrets.SUBNET_IDS }} # Comma-separated list of your subnet IDs
      SECURITY_GROUP_IDS: ${{ secrets.SECURITY_GROUP_IDS }} # Comma-separated list of your security group IDs

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY}}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create ECS Cluster (if it doesn't exist)
        run: |
          aws ecs describe-clusters --cluster-names $ECS_CLUSTER_NAME || \
          aws ecs create-cluster --cluster-name $ECS_CLUSTER_NAME

      - name: Create Backend Task Definition
        id: backend-task-def
        run: |
          TASK_DEFINITION=$(aws ecs register-task-definition \
            --family "$TASK_DEFINITION_FAMILY_BACKEND" \
            --network-mode "awsvpc" \
            --requires-compatibilities "FARGATE" \
            --cpu "256" \
            --memory "512" \
            --execution-role-arn "arn:aws:iam::$AWS_ACCOUNT_ID:role/ecsTaskExecutionRole" \
            --container-definitions "[
              {
                \"name\": \"$CONTAINER_NAME_BACKEND\",
                \"image\": \"$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$BACKEND_REPO_NAME:latest\",
                \"portMappings\": [
                  {
                    \"containerPort\": $BACKEND_PORT,
                    \"protocol\": \"tcp\"
                  }
                ],
                \"logConfiguration\": {
                  \"logDriver\": \"awslogs\",
                  \"options\": {
                    \"awslogs-group\": \"/ecs/$ECS_SERVICE_NAME_BACKEND\",
                    \"awslogs-region\": \"$AWS_REGION\",
                    \"awslogs-stream-prefix\": \"backend\"
                  }
                }
              }
            ]" --output json)
          TASK_DEFINITION_ARN=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.taskDefinitionArn')
          echo "BACKEND_TASK_DEFINITION_ARN=$TASK_DEFINITION_ARN" >> $GITHUB_OUTPUT

      - name: Create or Update Backend ECS Service
        run: |
          if aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME_BACKEND > /dev/null 2>&1; then
            echo "Updating existing backend service..."
            aws ecs update-service --cluster $ECS_CLUSTER_NAME --service $ECS_SERVICE_NAME_BACKEND --task-definition ${{ steps.backend-task-def.outputs.BACKEND_TASK_DEFINITION_ARN }} --force-new-deployment
          else
            echo "Creating new backend service..."
            aws ecs create-service --cluster $ECS_CLUSTER_NAME --service-name $ECS_SERVICE_NAME_BACKEND --task-definition ${{ steps.backend-task-def.outputs.BACKEND_TASK_DEFINITION_ARN }} --desired-count 1 \
              --launch-type "FARGATE" \
              --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SECURITY_GROUP_IDS],assignPublicIp=ENABLED}"
          fi

      - name: Create Frontend Task Definition
        id: frontend-task-def
        run: |
          TASK_DEFINITION=$(aws ecs register-task-definition \
            --family "$TASK_DEFINITION_FAMILY_FRONTEND" \
            --network-mode "awsvpc" \
            --requires-compatibilities "FARGATE" \
            --cpu "256" \
            --memory "512" \
            --execution-role-arn "arn:aws:iam::$AWS_ACCOUNT_ID:role/ecsTaskExecutionRole" \
            --container-definitions "[
              {
                \"name\": \"$CONTAINER_NAME_FRONTEND\",
                \"image\": \"$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$FRONTEND_REPO_NAME:latest\",
                \"portMappings\": [
                  {
                    \"containerPort\": $FRONTEND_PORT,
                    \"protocol\": \"tcp\"
                  }
                ],
                \"logConfiguration\": {
                  \"logDriver\": \"awslogs\",
                  \"options\": {
                    \"awslogs-group\": \"/ecs/$ECS_SERVICE_NAME_FRONTEND\",
                    \"awslogs-region\": \"$AWS_REGION\",
                    \"awslogs-stream-prefix\": \"frontend\"
                  }
                }
              }
            ]" --output json)
          TASK_DEFINITION_ARN=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.taskDefinitionArn')
          echo "FRONTEND_TASK_DEFINITION_ARN=$TASK_DEFINITION_ARN" >> $GITHUB_OUTPUT

      - name: Create or Update Frontend ECS Service
        run: |
          if aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME_FRONTEND > /dev/null 2>&1; then
            echo "Updating existing frontend service..."
            aws ecs update-service --cluster $ECS_CLUSTER_NAME --service $ECS_SERVICE_NAME_FRONTEND --task-definition ${{ steps.frontend-task-def.outputs.FRONTEND_TASK_DEFINITION_ARN }} --force-new-deployment
          else
            echo "Creating new frontend service..."
            aws ecs create-service --cluster $ECS_CLUSTER_NAME --service-name $ECS_SERVICE_NAME_FRONTEND --task-definition ${{ steps.frontend-task-def.outputs.FRONTEND_TASK_DEFINITION_ARN }} --desired-count 1 \
              --launch-type "FARGATE" \
              --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SECURITY_GROUP_IDS],assignPublicIp=ENABLED}"
          fi

      # Optional: If you are using an Application Load Balancer
      - name: Update Backend Target Group (if using ALB)
        if: ${{ env.LOAD_BALANCER_NAME != '' && env.LISTENER_ARN != '' }}
        run: |
          TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups --load-balancer-arn "arn:aws:elasticloadbalancing:$AWS_REGION:$AWS_ACCOUNT_ID:loadbalancer/app/$LOAD_BALANCER_NAME/*" --names $ECS_SERVICE_NAME_BACKEND | jq -r '.TargetGroups[0].TargetGroupArn')
          aws ecs update-service --cluster $ECS_CLUSTER_NAME --service $ECS_SERVICE_NAME_BACKEND --task-definition ${{ steps.backend-task-def.outputs.BACKEND_TASK_DEFINITION_ARN }} --force-new-deployment --load-balancers "targetGroupArn=$TARGET_GROUP_ARN,containerName=$CONTAINER_NAME_BACKEND,containerPort=$BACKEND_PORT"

      - name: Update Frontend Target Group (if using ALB)
        if: ${{ env.LOAD_BALANCER_NAME != '' && env.LISTENER_ARN != '' }}
        run: |
          TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups --load-balancer-arn "arn:aws:elasticloadbalancing:$AWS_REGION:$AWS_ACCOUNT_ID:loadbalancer/app/$LOAD_BALANCER_NAME/*" --names $ECS_SERVICE_NAME_FRONTEND | jq -r '.TargetGroups[0].TargetGroupArn')
          aws ecs update-service --cluster $ECS_CLUSTER_NAME --service $ECS_SERVICE_NAME_FRONTEND --task-definition ${{ steps.frontend-task-def.outputs.FRONTEND_TASK_DEFINITION_ARN }} --force-new-deployment --load-balancers "targetGroupArn=$TARGET_GROUP_ARN,containerName=$CONTAINER_NAME_FRONTEND,containerPort=$FRONTEND_PORT"

